---
sidebar_position: 3
description: 响应规则的使用
---

import Messenger from "@site/src/components/Messenger";

# `on_alconna` 响应器

`nonebot_plugin_alconna` 插件本体的大部分功能都围绕着 `on_alconna` 响应器展开。

该响应器类似于 `on_command`，基于 `Alconna` 解析器来解析命令。

以下是一个简单的 `on_alconna` 响应器的例子：

```python
from nonebot_plugin_alconna import At, Image, Match, on_alconna
from arclet.alconna import Args, Option, Alconna, MultiVar, Subcommand


alc = Alconna(
    "role-group",
    Subcommand(
        "add|添加",
        Args["name", str],
        Option("member", Args["target", MultiVar(At)]),
        dest="add",
        compact=True,
    ),
    Option("list"),
    Option("icon", Args["icon", Image])
)
rg = on_alconna(alc, use_command_start=True, aliases={"角色组"})


@rg.assign("list")
async def list_role_group():
    img: bytes = await gen_role_group_list_image()
    await rg.finish(Image(raw=img))

@rg.assign("add")
async def _(name: str, target: Match[tuple[At, ...]]):
    group = await create_role_group(name)
    if target.available:
        ats: tuple[At, ...] = target.result
        group.extend(member.target for member in ats)
    await rg.finish("添加成功")
```

<Messenger
  msgs={[
    { position: "right", msg: "/role-group list" },
    {
      position: "left",
      msg: "[图片]",
    },
    { position: "right", msg: "/角色组 添加foo @bar @baz" },
    { position: "left", msg: "添加成功" },
  ]}
/>


## 使用

`on_alconna` 的参数如下:

```python
def on_alconna(
    command: Alconna | str,
    rule: Rule | T_RuleChecker | None = None,
    skip_for_unmatch: bool = True,
    auto_send_output: bool | None = None,
    aliases: set[str] | tuple[str, ...] | None = None,
    comp_config: CompConfig | None = None,
    extensions: list[type[Extension] | Extension] | None = None,
    exclude_ext: list[type[Extension] | str] | None = None,
    use_origin: bool | None = None,
    use_cmd_start: bool | None = None,
    use_cmd_sep: bool | None = None,
    response_self: bool | None = None,
    **kwargs: Any,
) -> type[AlconnaMatcher]:
    ...
```

- `command`: Alconna 命令或字符串，字符串将通过 `AlconnaFormat` 转换为 Alconna 命令
- `rule`: 事件响应规则， 详见 [响应器规则](../advanced/matcher.md#事件响应规则)
- `skip_for_unmatch`: 是否在命令不匹配时跳过该响应, 默认为 `True`
- `auto_send_output`: 是否自动发送输出信息并跳过该响应。
  - `True`：自动发送输出信息并跳过该响应
  - `False`：不自动发送输出信息，而是传递进行处理
  - `None`：跟随全局配置项 `alconna_auto_send_output`，默认值为 `True`
- `aliases`: 命令别名， 作用类似于 `on_command` 中的 aliases
- `comp_config`: 补全会话配置， 不传入则不启用补全会话
- `extensions`: 需要加载的匹配扩展, 可以是扩展类或扩展实例
- `exclude_ext`: 需要排除的匹配扩展, 可以是扩展类或扩展的id
- `use_origin`: 是否使用未经 to_me 等处理过的消息。`None` 时跟随全局配置项 `alconna_use_origin`，默认值为 `False`
- `use_cmd_start`: 是否使用 COMMAND_START 作为命令前缀。`None` 时跟随全局配置项 `alconna_use_command_start`，默认值为 `False`
- `use_cmd_sep`: 是否使用 COMMAND_SEP 作为命令分隔符。`None` 时跟随全局配置项 `alconna_use_command_sep`，默认值为 `False`
- `response_self`: 是否响应自身消息。`None` 时跟随全局配置项 `alconna_response_self`，默认值为 `False`

`on_alconna` 返回的是 `Matcher` 的子类 `AlconnaMatcher` ，其拓展了如下方法：

- `.assign(path, value, or_not)`: 用于对包含多个选项/子命令的命令的分派处理
- `.dispatch`: 同样的分派处理，但是是类似 `CommandGroup` 一样返回新的 `AlconnaMatcher`
- `.got_path(path, prompt, middleware)`: 在 `got` 方法的基础上，会以 path 对应的参数为准，读取传入 message 的最后一个消息段并验证转换
- `.got`, `send`, `reject`, ... : 拓展了 prompt 类型，即支持使用 `UniMessage` 作为 prompt
- ...

