---
sidebar_position: 2
description: 测试事件响应和平台接口调用
---

# 测试事件响应和平台接口调用

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

在 NoneBot 接收到事件时，事件响应器根据优先级依次通过权限、响应规则来判断当前事件是否应该触发。事件响应流程中，机器人可能会通过 `send` 发送消息或者调用平台接口来执行预期的操作。因此，我们需要对这两种操作进行单元测试。

在上一节中，我们对单个事件响应器进行了简单测试。但是在实际场景中，机器人可能定义了多个事件响应器，由于优先级和响应规则的存在，预期的事件响应器可能并不会被触发。NoneBug 支持同时测试多个事件响应器，以此来测试机器人的整体行为。

## 测试事件响应

NoneBug 提供了六种定义 `Rule` 和 `Permission` 预期行为的方法：

- `should_pass_rule`
- `should_not_pass_rule`
- `should_ignore_rule`
- `should_pass_permission`
- `should_not_pass_permission`
- `should_ignore_permission`

下面我们根据插件示例来测试事件响应行为，我们首先定义两个事件响应器作为测试的对象：

```python title=example.py
from nonebot import on_command

def never_pass():
    return False

foo = on_command("foo")
bar = on_command("bar", permission=never_pass)
```

在这两个事件响应器中，`foo` 当收到 `/foo` 消息时会执行，而 `bar` 则不会执行。我们使用 NoneBug 来测试它们：

<Tabs groupId="testScope">
  <TabItem value="separate" label="独立测试" default>

```python {21,22,28,29} title=test_example.py
import pytest
from nonebug import App
from nonebot.adapters.console import User, Message, MessageEvent

def make_event(message: str = "") -> MessageEvent:
    return MessageEvent(
        time=datetime.now(),
        self_id=bot.self_id,
        message=Message(message),
        user=User(user_id=123456789),
    )

@pytest.mark.asyncio
async def test_example(app: App):
    from awesome_bot.plugins.example import foo, bar

    async with app.test_matcher(foo) as ctx:
        bot = ctx.create_bot()
        event = make_event("/foo")
        ctx.receive_event(bot, event)
        ctx.should_pass_rule()
        ctx.should_pass_permission()

    async with app.test_matcher(bar) as ctx:
        bot = ctx.create_bot()
        event = make_event("/foo")
        ctx.receive_event(bot, event)
        ctx.should_not_pass_rule()
        ctx.should_not_pass_permission()
```

在上面的代码中，我们分别对 `foo` 和 `bar` 事件响应器进行响应测试。我们使用 `ctx.should_pass_rule` 和 `ctx.should_pass_permission` 断言 `foo` 事件响应器应该被触发，使用 `ctx.should_not_pass_rule` 和 `ctx.should_not_pass_permission` 断言 `bar` 事件响应器应该被忽略。

  </TabItem>
  <TabItem value="global" label="整体测试">

```python title=test_example.py
import pytest
from nonebug import App
from nonebot.adapters.console import User, Message, MessageEvent

def make_event(message: str = "") -> MessageEvent:
    return MessageEvent(
        time=datetime.now(),
        self_id=bot.self_id,
        message=Message(message),
        user=User(user_id=123456789),
    )

@pytest.mark.asyncio
async def test_example(app: App):
    from awesome_bot.plugins.example import foo, bar

    async with app.test_matcher() as ctx:
        bot = ctx.create_bot()
        event = make_event("/foo")
        ctx.receive_event(bot, event)
        ctx.should_pass_rule(foo)
        ctx.should_pass_permission(foo)
        ctx.should_not_pass_rule(bar)
        ctx.should_not_pass_permission(bar)
```

在上面的代码中，我们对 `foo` 和 `bar` 事件响应器一起进行响应测试。我们使用 `ctx.should_pass_rule` 和 `ctx.should_pass_permission` 断言 `foo` 事件响应器应该被触发，使用 `ctx.should_not_pass_rule` 和 `ctx.should_not_pass_permission` 断言 `bar` 事件响应器应该被忽略。通过参数，我们可以指定断言的事件响应器。

  </TabItem>
</Tabs>

当然，如果需要忽略某个事件响应器的响应规则和权限检查，强行进入响应流程，我们可以使用 `should_ignore_rule` 和 `should_ignore_permission` 方法：

```python {21,22} title=test_example.py
import pytest
from nonebug import App
from nonebot.adapters.console import User, Message, MessageEvent

def make_event(message: str = "") -> MessageEvent:
    return MessageEvent(
        time=datetime.now(),
        self_id=bot.self_id,
        message=Message(message),
        user=User(user_id=123456789),
    )

@pytest.mark.asyncio
async def test_example(app: App):
    from awesome_bot.plugins.example import foo, bar

    async with app.test_matcher(bar) as ctx:
        bot = ctx.create_bot()
        event = make_event("/foo")
        ctx.receive_event(bot, event)
        ctx.should_ignore_rule(bar)
        ctx.should_ignore_permission(bar)
```

在忽略了响应规则和权限检查之后，就会进入 `bar` 事件响应器的响应流程。

## 测试平台接口调用
